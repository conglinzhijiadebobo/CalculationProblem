### 【C】四则运算
---
| PSP2.1                                  | Personal Software Process Stages        | 预估耗时（分钟） | 实际耗时（分钟） |
|-----------------------------------------|-----------------------------------------|------------------|------------------|
| Planning                                | 计划                                    |                  |                  |
| · Estimate                              | · 估计这个任务需要多少时间              |                  |                  |
| Development                             | 开发                                    |                  |                  |
| · Analysis                              | · 需求分析 (包括学习新技术)             |                  |                  |
| · Design Spec                           | · 生成设计文档                          |                  |                  |
| · Design Review                         | · 设计复审 (和同事审核设计文档)         |                  |                  |
| · Coding Standard                       | · 代码规范 (为目前的开发制定合适的规范) |                  |                  |
| · Design                                | · 具体设计                              |                  |                  |
| · Coding                                | · 具体编码                              |                  |                  |
| · Code Review                           | · 代码复审                              |                  |                  |
| · Test                                  | · 测试（自我测试，修改代码，提交修改）  |                  |                  |
| Reporting                               | 报告                                    |                  |                  |
| · Test Report                           | · 测试报告                              |                  |                  |
| · Size Measurement                      | · 计算工作量                            |                  |                  |
| · Postmortem & Process Improvement Plan | · 事后总结, 并提出过程改进计划          |                  |                  |
| 合计                                    |                                         |                  |                  |

###程序设计
####需求分析
将程序分为**表达式生成**和**答案核对**两部分  

- **表达式生成**所要求的功能有：  
1.**随机**生成符合正确数学规则的表达式       
2.可以通过参数控制题目中数值的大小  
3.查重。即任何两道题目不能通过有限次交换+和x左右的算术表达式变换为同一道题目  
4.将生成的文件以固定的格式写入txt文件中  

- **答案核对**所要求的功能有：  
1.计算txt文件中的数学表达式的答案  
2.将答案文件写入Answers.txt文件中  
3.对给定的题目文件和答案文件，判定答案中的对错，并进行数量统计  

####解题思路
首先是表达式生成，其核心要满足**随机性**，特别是括号的生成，一开始我们讨论出两套方案：  

- 一是利用二叉树的中序遍历，其结构如下：  
![](https://i.imgur.com/E1gNDrb.png)  
方法是每次访问父结点时，自动带上括号，这样最终的表达式生成公式为：  
$$
\((A op1 B)op2(C op3 D))
$$  
注释：`ABCD`是变量，`op1`、`op2`和`op3`是运算符  
但是这个方案不一定是随机的，无法生成一对括号中有三个变量的运算，如 \\((3+4+5)*6\\) 
 
- 第二种方案就是正面莽，基于左括号`(`只能在运算符的后面一位，右括号`)`只能在变量的后面一位这一特点，分别写**左括号生成函数**和**右括号生成函数**。每次生成数值或运算符后进行一次判断。

----------

这里是核对答案部分

----------  
###代码说明部分

将变量放入结构体中    

	struct Variable
	{
	char *val;
	int left = 0;			//1：变量有左侧有左括号
	int right = 0;
	int ator = 0;		//1：变量为分数
	int size = 0;
	};
   
括号生成函数

	BOOL BCL(char *calproblem, int x, int num)					//nur after op
	{
	extern int LB, RB;
		switch (rand() % 4)
		{
		case 0:
		{
			if (LB<2&&(num - x) >= 2)
			{
				strcat_s(calproblem, strlen(calproblem) + sizeof(char) + 1, "(");
				LB++;
				m_VarStruct[x].left = 1;
				return 1;
			}

		}
		break;
		case 2:
		{
			if (LB == 0 && (num - x >= 3))
			{
				strcat_s(calproblem, strlen(calproblem) + 2 * sizeof(char) + 1, "((");
				LB = 2;
				m_VarStruct[x].left = 2;
				return 1;
			}
		}
		break;
		default:
			break;
		}
	return 0;
	}
	BOOL BCR(char *calproblem, int x, int num)			//nur after Var
	{
	extern int LB, RB;
	if (RB == 2 || LB==0) return 0;
	if (LB <= 2)
	{
		switch (rand() % 2)
		{
		case 1:
		{
			if (!m_VarStruct[x].left)
			{
				strcat_s(calproblem, strlen(calproblem) + strlen("(") + sizeof("\0"), ")");
				RB++;
				m_VarStruct[x].right = 1;
				return 1;
			}
		}
		break;
		case 0:
		{
			if (!m_VarStruct[x].left&&LB == 2 && RB == 0)
			{
				strcat_s(calproblem, strlen(calproblem) + 2 * sizeof(char) + 1, "))");
				RB = 2;
				m_VarStruct[x].right = 2;
				return 1;
			}
		}
		break;
		default:
			break;
		}
	}
	return 0;
	}



----------

###测试运行  

	***********************
	可用参数如下：
	-r  <题目的数字最大值>
	-n <题目的数量>
	-e <题目文件位置>
	-a <答题卡文件位置>
	-h "帮助"
	***********************
- 表达式生成部分   
![](https://i.imgur.com/XkIMf1T.png)
![](https://i.imgur.com/t5A52OI.png)
可支持生成100k道题目  
生成10k道题目的时间为18ms的CPU时间

- 答案生成部分
![](https://i.imgur.com/eha7zZf.png)
生成10k道题目的时间为63ms的CPU时间

- 核对答案部分  
答题卡（测试文件）包括五道正确，两道错误，其余为空
![](https://i.imgur.com/n1v5Hgm.png)
成绩
![](https://i.imgur.com/C3IOxBY.png)
对比10k道题目的时间为55ms的CPU时间

####效能分析
![](https://i.imgur.com/PvN0KOK.png)  
程序中最占时间的函数是`SaveAnswers`、`AnAnswer`、`OoenFielAndGiveTheAnswer`和`CompareAndGiveTheGrade`四个函数，都是和答案生成有关，其中三个函数都调用了`AnAnswer`函数，这个函数的定义是：
> Element AnAnswer(char s[40]); //计算得出答案项,并将答案存入结构体中

`AnAnswer`函数的调用情况如下：
![](https://i.imgur.com/iTUwTHE.png)
可以看到AnAnswer函数中最耗时间的是`malloc`内存分配，第二耗时的是` GetNumberFromStr()`函数，其定义如下
> Element GetNumberFromStr(char s[]);	 //从含单个数的字符数组中得出相应的值,将int转化成字符数组存储

其中最耗时的是int转化为字符数组的库函数`itoa`

----------


###项目小结
在本次开发中，我遇到的最困难的问题就是内存分配问题，特别是数组越界的判断，真的是<font color="#89AE44"> <del>不怕恋人出轨，就怕数组出界</del></font>  
存放表达式的数组原本我想设计成响应式的，即可以根据不同数值的变量分配不同大小的内存，以减少内存的使用，但是一直触发内存访问错误的断点。大改了两三次，重写了一次，小修补十几次。  
已探明的问题主要在以下几个方面：  
1.数组大小估计不足。主要是因为对数组的概念不明确

>char str[20]="0123456789";   
>>int a=strlen(str); //a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。   
> int b=sizeof(str); //而b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。   
> 
> 上面是对静态数组处理的结果，如果是对指针，结果就不一样了   
> char* ss = "0123456789";   
>> sizeof(ss) 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4   
>> sizeof(*ss) 结果1 ＝＝＝》`*ss`是第一个字符 其实就是获得了字符串的第一位'0' 所占的内存空间，是char类型的，占了 1 位  
>> strlen(ss)= 10 >>>> 如果要获得这个字符串的长度，则一定要使用 strlen

|char|[0]|[1]|[2]|[3]|[4]|[5]|[6]|[7]|[8]|[9]|
|
|	|A|B|C|D|E|F|G|H|\0|\0|
如果没有结尾的`\0`，数组就会出界。**`calloc`和`malloc`两个函数直接输入所需元素的个数**，编译器会自动分配一个空间存放`\0`接在后面。  
2.字符数组结尾没有加上`\0`,这个错误主要是`strcpy_s`和`strcat_s`两个函数中关于数组大小参数的使用。  
